import { supabase } from './supabase';
import type { Tables } from './supabase';

// Types
export type User = Tables['users']['Row'];
export type Transaction = Tables['transactions']['Row'];
export interface TransactionCondition {
  description: string;
  completed: boolean;
}

// User Management
export const saveUser = async (userData: Omit<User, 'created_at' | 'vault_id' | 'id' | 'balance' | 'unread_transactions' | 'escrow_balance'>): Promise<void> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError) {
      console.error('Session error:', sessionError);
      throw new Error('Session error: ' + sessionError.message);
    }
    
    if (!session?.user) {
      console.error('No active session found');
      throw new Error('No active session found');
    }

    // Insert the user into the users table
    const { error: insertError } = await supabase
      .from('users')
      .insert({
        ...userData,
        email: userData.email.toLowerCase(),
        // vault_id will be automatically generated by the trigger
      });

    if (insertError) {
      console.error('Failed to create user record:', insertError);
      throw new Error('Failed to create user record: ' + insertError.message);
    }

    console.log('User record created successfully');
    return;
  } catch (error) {
    console.error('Save user error:', error);
    throw error;
  }
};

export const getUsers = async (): Promise<User[]> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    const { data, error } = await supabase
      .from('users')
      .select('id, name, email, vault_id, created_at')
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('Database error:', error);
      throw error;
    }
    return data || [];
  } catch (error) {
    console.error('Error getting users:', error);
    return [];
  }
};

export const findUserByEmail = async (email: string): Promise<User | null> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('email', email.toLowerCase())
      .maybeSingle();
    
    if (error) {
      console.error('Database error:', error);
      throw error;
    }
    return data;
  } catch (error) {
    console.error('Error finding user by email:', error);
    return null;
  }
};

export const findUserByVaultId = async (vaultId: string): Promise<User | null> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    console.log('Searching for user with VID:', vaultId);
    const { data, error } = await supabase
      .from('users')
      .select('id, name, vault_id')
      .eq('vault_id', vaultId.toUpperCase())
      .maybeSingle();
    
    if (error) {
      console.error('Database error:', error);
      throw new Error('Failed to search for user');
    }

    console.log('Found user:', data);
    return data;
  } catch (error) {
    console.error('Error finding user by VaultID:', error);
    throw error;
  }
};

export const updateUser = async (userId: string, updates: Partial<User>): Promise<void> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    console.log('Updating user:', userId, 'with:', updates);
    const { error } = await supabase
      .from('users')
      .update(updates)
      .eq('id', userId);
    
    if (error) {
      console.error('Database error:', error);
      throw error;
    }
    console.log('User updated successfully');
  } catch (error) {
    console.error('Error updating user:', error);
    throw new Error('Failed to update user');
  }
};

// Transaction Management
export const saveTransaction = async (transaction: Omit<Transaction, 'id' | 'created_at' | 'vtid'>): Promise<Transaction> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    // First, verify sender has sufficient balance
    const { data: sender } = await supabase
      .from('users')
      .select('balance, escrow_balance')
      .eq('id', transaction.sender_id)
      .single();

    if (!sender || sender.balance < transaction.amount) {
      throw new Error('Insufficient balance');
    }

    // Start a transaction using RPC
    const { data: transactionResult, error: transactionError } = await supabase.rpc(
      'create_transaction_with_escrow',
      {
        p_sender_id: transaction.sender_id,
        p_receiver_id: transaction.receiver_id,
        p_amount: transaction.amount,
        p_conditions: transaction.conditions,
        p_time_limit: transaction.time_limit
      }
    );

    if (transactionError || !transactionResult) {
      console.error('Transaction creation error:', transactionError);
      throw new Error('Failed to create transaction');
    }

    return transactionResult;
  } catch (error) {
    console.error('Error saving transaction:', error);
    throw error;
  }
};

export const getTransactions = async (): Promise<Transaction[]> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) {
      console.error('Database error:', error);
      throw error;
    }
    return data || [];
  } catch (error) {
    console.error('Error getting transactions:', error);
    return [];
  }
};

export const updateTransaction = async (
  transactionId: string,
  updates: Partial<Transaction>
): Promise<void> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    // Get current transaction
    const { data: transaction } = await supabase
      .from('transactions')
      .select('*')
      .eq('id', transactionId)
      .single();

    if (!transaction) {
      throw new Error('Transaction not found');
    }

    // Use RPC to handle status updates and balance transfers
    if (updates.status === 'completed' || updates.status === 'cancelled') {
      const { error: updateError } = await supabase.rpc(
        'update_transaction_status',
        {
          p_transaction_id: transactionId,
          p_new_status: updates.status
        }
      );

      if (updateError) {
        throw updateError;
      }
    } else {
      // For other updates that don't affect balances
      const { error } = await supabase
        .from('transactions')
        .update(updates)
        .eq('id', transactionId);
      
      if (error) {
        throw error;
      }
    }

  } catch (error) {
    console.error('Error updating transaction:', error);
    throw new Error('Failed to update transaction');
  }
};

// Notification Management
export const markTransactionAsRead = async (userId: string, transactionId: string): Promise<void> => {
  try {
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      console.error('No active session:', sessionError);
      throw new Error('No active session');
    }

    console.log('Marking transaction as read:', transactionId, 'for user:', userId);

    const { data: user, error: fetchError } = await supabase
      .from('users')
      .select('unread_transactions')
      .eq('id', userId)
      .single();
    
    if (fetchError) {
      console.error('Fetch error:', fetchError);
      throw fetchError;
    }
    
    const unreadTransactions = user?.unread_transactions || [];
    const updatedUnread = unreadTransactions.filter(id => id !== transactionId);
    
    const { error: updateError } = await supabase
      .from('users')
      .update({ unread_transactions: updatedUnread })
      .eq('id', userId);
    
    if (updateError) {
      console.error('Update error:', updateError);
      throw updateError;
    }

    console.log('Transaction marked as read successfully');
  } catch (error) {
    console.error('Error marking transaction as read:', error);
    throw new Error('Failed to mark transaction as read');
  }
};

export { findUserByVaultId, saveTransaction, updateUser }

export { saveUser, findUserByEmail }

export { getTransactions, getUsers }